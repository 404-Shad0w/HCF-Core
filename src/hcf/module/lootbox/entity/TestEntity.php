<?php
namespace hcf\module\lootbox\entity;

use hcf\HCFLoader;
use pocketmine\entity\EntitySizeInfo;
use pocketmine\entity\Living;
use pocketmine\entity\Location;
use pocketmine\event\entity\EntityDamageEvent;
use pocketmine\item\Item;
use pocketmine\nbt\tag\CompoundTag;
use pocketmine\network\mcpe\convert\TypeConverter;
use pocketmine\network\mcpe\protocol\MobEquipmentPacket;
use pocketmine\network\mcpe\protocol\types\entity\EntityIds;
use pocketmine\network\mcpe\protocol\types\entity\EntityMetadataCollection;
use pocketmine\network\mcpe\protocol\types\entity\EntityMetadataProperties;
use pocketmine\network\mcpe\protocol\types\inventory\ContainerIds;
use pocketmine\network\mcpe\protocol\types\inventory\ItemStackWrapper;
use pocketmine\network\mcpe\protocol\types\inventory\WindowTypes;
use pocketmine\Server;
use pocketmine\world\particle\CriticalParticle;

class TestEntity extends Living
{

	protected Item $item_in_hand;

	public int $spins = 0;

	public Location $baseLoc;

	public FloatingEntity $entity;

	public array $spawned = [];

	public function __construct(Location $location, Location $baseLoc, ?CompoundTag $nbt = null)
	{
		$this->setInvisible(true);
		$this->baseLoc = $baseLoc;
		$this->entity = new FloatingEntity($this->baseLoc);
		$this->entity->spawnToAll();
		parent::__construct($location, $nbt);
	}

	public function attack(EntityDamageEvent $source): void
	{
		$source->cancel();
	}

	public function setPose(): void{
		$this->getNetworkProperties()->setInt(EntityMetadataProperties::ARMOR_STAND_POSE_INDEX, 2);
		$this->scheduleUpdate();
	}

	public function setBaseLoc(Location $location): void{
		$this->baseLoc = $location;
	}

	protected function getInitialSizeInfo(): EntitySizeInfo
	{
		return new EntitySizeInfo(1, 1);
	}


	public function getSpins(): int
	{
		return $this->spins;
	}

	public function addSpin(): void
	{
		$this->spins++;
	}

	public function getItemInHand(): Item
	{
		return $this->item_in_hand;
	}

	public function hasItem(): bool
	{
		return $this->item_in_hand instanceof Item;
	}

	public function setItemInHand(Item $item_in_hand): void
	{
		$this->item_in_hand = $item_in_hand;
		$packet = MobEquipmentPacket::create($this->getId(), ItemStackWrapper::legacy(TypeConverter::getInstance()->coreItemStackToNet($this->getItemInHand())), 0, ContainerIds::INVENTORY, WindowTypes::INVENTORY);
		foreach ($this->getViewers() as $viewer) {
			$viewer->getNetworkSession()->sendDataPacket($packet);
		}
	}


	public function onUpdate(int $currentTick = 1): bool
	{
		if($this->location->yaw > 360){
			$this->location->yaw = 0;
		}else{
			$this->location->yaw+= 15;
		}
		$spins = $this->getSpins();
		$speed = 2 * 3.141 / 2;
		$angle = $speed * $spins;
		$loc = $this->rotLoc($this->baseLoc, 4.0, $angle);
		$vector = HCFLoader::getRandomVector()->multiply(4);
		$this->baseLoc->getWorld()->addParticle($this->location->add($vector->x, $vector->y, $vector->z), new CriticalParticle());
		$this->baseLoc->add($vector->x, $vector->y, $vector->z);
		$this->teleport($loc);
		$this->entity->setNameTag($this->getItemInHand()->getName());
		$this->entity->teleport($loc);
		$this->addSpin();
		return parent::onUpdate($currentTick); // TODO: Change the autogenerated stub
	}

	public function getEntity(): FloatingEntity{
		return $this->entity;
	}


	/**
	 * @param Location $location
	 * @param float $radius
	 * @param float $angle
	 * @return Location
	 */
	public function rotLoc(Location $location, float $radius, float $angle): Location{
		$z = $location->getZ() + $radius * sin($angle / 90);
		$x = $location->getX() + $radius * cos($angle / 90);
		return new Location($x, $location->getY() + 0.2, $z, Server::getInstance()->getWorldManager()->getDefaultWorld(), 0, 0);	}


	public static function getNetworkTypeId(): string
	{
		return EntityIds::ARMOR_STAND;
	}

	public function getName(): string
	{
		return "LOL";
	}
}